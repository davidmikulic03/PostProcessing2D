#pragma kernel DCT
#pragma kernel IDCT

RWTexture2D<float4> Result;
RWTexture2D<float4> CleanRender;
RWTexture2D<float> Refresher;


float4x4 DeltaTransform;

float FOV;
float AspectRatio;
float Time;
float RefreshProbability;

float MaxColorDifference, SpreadThreshold;

int ResolutionX;
int ResolutionY;

uint rngState = 1;

float dct[64];
int quantizationMatrix[64];

float RandomValue(inout uint rngState)
{
    rngState = rngState * 747796405 + 2891336453;
    uint result = ((rngState >> ((rngState >> 28) + 4)) ^ rngState) * 277803737;
    result = (result >> 22) ^ result;
    return result / 4294967295.0;
}

float2 rotateUV(uint2 id)
{
    float2 uv = (id + 0.5f) / float2(ResolutionX, ResolutionY) - 0.5f;

    float3 position = float3(uv, 0);
    position = mul(DeltaTransform, position);

    return position.xy;
}

uint2 RotatePixel(uint2 id)
{
    float2 position = rotateUV(id);

    float2 floatID = ((position + 0.5f) * float2(ResolutionX, ResolutionY) - 0.4f);

    return min(max(floatID, 0), float2(ResolutionX, ResolutionY));
}


float3 Displacement(uint2 fromID, uint2 toID)
{
    return Result[fromID].xyz - Result[toID].xyz;
}

void Spread(uint2 id, float maxDist)
{
    float refreshRate = 0.01f;
    float defreshRate = 0.5f;

    uint2 offset = uint2(1, 0);
    for (uint i = 0; i < 4; i++)
    {
        if (i == 1)
            offset = uint2(0, 1);
        else if (i == 2)
            offset = uint2(-1, 0);
        else if (i == 3)
            offset = uint2(0, -1);

        if ((id + offset).x + 1 < ResolutionX && (id + offset).y + 1 < ResolutionY)
        {
            float4 outputColor = Result[id + offset];
            float3 disp = Displacement(id, id + offset);
            if (disp.r < maxDist)
                outputColor.r = Result[id].r;
            if (disp.g < maxDist)
                outputColor.g = Result[id].g;
            if (disp.b < maxDist)
                outputColor.b = Result[id].b;
            if (length(disp.rgb) < maxDist)
            {
                Refresher[id] += refreshRate;
            }
            else
            {
                Refresher[id] -= defreshRate;
            }
            Result[id + offset] = outputColor;
            //Refresher[id] = exp(-max(Refresher[id].x, 0));
            Refresher[id] = Refresher[id] * 0.75f + Refresher[id + offset] * 0.25f;
            Refresher[id] = clamp(Refresher[id + offset].x, 0, 1);
        }
    }
}

float3 toYCbCr(float3 rgb) {
    return mul(float3x3(
        0.299f, 0.587f, 0.114f,
        -0.168736f, -0.331264f, 0.5f,
        0.5f, -0.418688f, -0.081312f), rgb) +
        float3(0.0f, 0.5f, 0.5f);
}
float3 toRGB(float3 ybr) {
    return mul(float3x3(1.0f,0.0f,1.402f,1.0f,-0.344136f,-0.714136f,1.0f,1.772f,0.0f), ybr - float3(0.0f, 0.5f, 0.5f));
}
float3 SoftClamp(float3 value, float steepness) {
    return 1 - exp(-steepness * value);
}

float alpha(uint x) {
    return x != 0 ? 1.0f : 1.0 / sqrt(2);
}

float3 PreCompression(in uint2 coord, in RWTexture2D<float4> sampleTex) {
    uint seed = Time * (coord.x + coord.y * 31);
    float noise = RandomValue(seed) - 0.5f;
    const float noiseAmount = 0.0f;
    return (256.0f * ((toYCbCr(sampleTex[coord].rgb + noiseAmount * noise) - 0.5f)));
}

float2 idToUV(uint2 id) {
    return (float2)(id) / float2(ResolutionX, ResolutionY);
}
float3 Quantize(in float cullLimit, in float3 dct) {
    
    return round(dct * cullLimit) / cullLimit;
}

float3 DCT8x8(in uint2 id, in RWTexture2D<float4> sampleTex) {
    const float pi = 3.14159265359;
    const float2 uv = idToUV(id);
    
    uint2 block = id % 8;
    uint2 blockStart = id - block;
    
    float3 res = 0;
    for (uint u = 0; u < 8; u++) {
        for (uint v = 0; v < 8; v++) {
            res += PreCompression(id + uint2(u,v), sampleTex) *
                cos((2.0f * u + 1.0f) * block.x * pi / 16.0f) *
                cos((2.0f * v + 1.0f) * block.y * pi / 16.0f);
        }
    }
    return Quantize(0.1, res * 0.25 * alpha(uv.x) * alpha(uv.y));
}


float3 IDCT8x8(in uint2 id, in RWTexture2D<float4> sampleTex) {
    const float pi = 3.14159265359;
    const float2 uv = idToUV(id);
    
    uint2 block = id % 8;
    uint2 blockStart = id - block;
    //return 256 * (block.x != 0 && block.x != 8 && block.y != 0 && block.y != 8) - 128;
    
    //return quantizationMatrix[block.x + 8 * block.y];
    
    float3 res = 0;
    for(uint u = 0; u < 8; u++){
        for(uint v = 0; v < 8; v++){
            res += sampleTex[(blockStart + uint2(u,v))] *
                alpha(u) * alpha(v) * 
                cos((2.0f * block.x + 1.0f) * u * pi / 16.0f) * 
                cos((2.0f * block.y + 1.0f) * v * pi / 16.0f); 
        }
    }
    return res * 0.25f;
}

[numthreads(32,32,1)]
void DCT(uint3 id : SV_DispatchThreadID)
{
    //Result[id.xy] = float4(SoftClamp(CleanRender[id.xy]), 1);
    
    Result[id.xy] = float4(DCT8x8(id.xy, CleanRender), 1);

    //Result[id.xy] = float4(toYCbCr(CleanRender[id.xy].rgb), 1);
    
    //Result[id.xy] = float4(rotateUV(id.xy), 0, 0);
    //return;

    //uint2 newID = id.xy;
    //float4 lastCol = Result[newID];
    //float4 cleanCol = CleanRender[id.xy];
    //float refreshCol = Refresher[id.xy];

    //Result[id.xy] = Result[id.xy] > 1;
    
    //Spread(newID, SpreadThreshold);
    //
    //float maxDist = MaxColorDifference;
    //
    //float4 newCol = lastCol;
    //if(abs(lastCol.r - cleanCol.r) > maxDist)
    //    newCol.r = cleanCol.r;
    //if(abs(lastCol.g - cleanCol.g) > maxDist)
    //    newCol.g = cleanCol.g;
    //if(abs(lastCol.b - cleanCol.b) > maxDist)
    //    newCol.b = cleanCol.b;
    //Result[id.xy] = newCol;
    //
    //uint seed = (uint)(Time * (newID.x + 31 * newID.y));
    //
    //if(refreshCol < RefreshProbability)
    //Result[id.xy] = cleanCol;
}

[numthreads(32,32,1)]
void IDCT(uint3 id : SV_DispatchThreadID) {
    //CleanRender[id.xy] = Result[id.xy];
    CleanRender[id.xy] = float4(toRGB(IDCT8x8(id.xy, Result) / 256 + 0.5f), 1);
    //CleanRender[id.xy] = float4(Quantize(id.xy, CleanRender[id.xy]), 1);
    
    //uint2 block = id.xy % 8;
    //CleanRender[id.xy] = quantizationMatrix[block.x + 8 * block.y] > 20;
    //if(block.x == 0 || block.x == 7)
    //    CleanRender[id.xy] *= float4(1, 0, 0, 0);
    //if(block.y == 0 || block.y == 7)
    //    CleanRender[id.xy] *= float4(1, 0, 0, 0);

    
    //CleanRender[id.xy] = IDCT8x8(id.xy, Result).r < 1;
    //Result[id.xy] = float4(toRGB(0.5f + (IDCT8x8(id.xy, Result) / 256.0f)), 1);
}